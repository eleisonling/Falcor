#pragma once
import Scene.Raytracing;
#include "Samples/SvoGi/Shaders/VoxelizationMeta.slangh"


inline float3 convert_world_to_svo_space(float3 worldPos, float3 cellMin, float3 cellMax) {
    float3 worldExtent = cellMax - cellMin;  
    float maxAxis = max(worldExtent.x, max(worldExtent.y, worldExtent.z));
    float3 convertedPos = (worldPos - cellMin) / float3(maxAxis) + float3(1.0);
    return convertedPos;
}


inline float copy_sign_32f(float newVal, float oldVal) {
    uint32_t oldValSign = asuint(oldVal) & SIGN_BIT_32;
    uint32_t clearSign = asuint(newVal) & (SIGN_BIT_32 - 1);
    return asfloat(clearSign | oldValSign);
}


struct Stack {
    int4 StackData[MAX_LEVEL + 1] = {};
};

inline bool intersect_ray_with_AABB(in RayDesc ray, float3 posMin, float3 posMax, out float tEnter, out float tLeave) {
    float3 tempMin = (posMin - ray.Origin) / ray.Direction;
    float3 tempMax = (posMax - ray.Origin) / ray.Direction;

    float3 tMax = max(tempMax, tempMin);
    float3 tMin = min(tempMax, tempMin);
    
    tLeave = min(tMax.x, min(tMax.y, tMax.z));
    tEnter = max(tMin.x, max(tMin.y, tMin.z));

    return tLeave > tEnter;
}

inline void correct_alpha(inout float4 color, in float alphaCorrection) {
    const float oldColA = color.a;
    color.a = 1.0f - pow((1.0f - color.a), alphaCorrection);
    color.xyz *= color.a / clamp(oldColA, 0.0001, 10000.0);
}


inline float4 ray_cast(in uint3 brickCoords, in float3 enter, in float3 leave, in float3 dir, in uint32_t level, in float nodeScale, in VoxelizationMeta meta,
    in Texture3D<float4> texBrick, in SamplerState spTexture) {

    float voxelStep = 1.0f / meta.BrickPoolResolution;
    float4 color = {0};

    float3 brickAddressUVW = float3(brickCoords) / meta.BrickPoolResolution + float3(voxelStep / 2.0f);
    float3 enterUVW = brickAddressUVW + enter * (2 * voxelStep);
    float3 leaveUVW = brickAddressUVW + leave * (2 * voxelStep);

    const float stepLength = length(leaveUVW - enterUVW);
    const float samplingRate = 3.0f;
    const float stepSize = voxelStep / samplingRate;
    const float fSampleCount = stepLength / stepSize;
    const int32_t iSampleCount = int32_t(ceil(fSampleCount));

    float alphaCorrection = float(g_Pow2[meta.TotalLevel]) / (float(g_Pow2[level + 1]) * samplingRate);

    for(int32_t i = 0; i < iSampleCount; ++i) {
        float3 samplePos = enterUVW + dir * stepSize * float(i);
        float4 newCol = texBrick.SampleLevel(spTexture, samplePos, 0);

        if(i == iSampleCount - 1) {
            alphaCorrection *= frac(fSampleCount);
        }
        correct_alpha(newCol, alphaCorrection);
        color += (1 - color.a) * newCol;

        if(color.a > 0.99) {
            break;
        }
    }

    return color;
}

inline void get_voxel_spatital_info(in Stack stack, int32_t scale, uint32_t childShift, float childScale, out float3 minPos, out float3 maxPos) {
    minPos = float3(0);
    maxPos = float3(0);

    for(int32_t i = MAX_LEVEL - 1; i >= scale; --i) {
        minPos += asfloat(stack.StackData[i].z) * childOffsets[stack.StackData[i].w];
    }

    minPos += childOffsets[childShift] * childScale + float3(1.0f);
    maxPos = minPos + childScale;
}


interface ITracingHitInfo {
    [mutating]
    bool deal_if_hitted(uint32_t parent, uint32_t childShift, int32_t scale, Stack stack, float expScale, float t); 
};

void trace_sparse_voxel_ray<T : ITracingHitInfo>(inout RayDesc ray, RWByteAddressBuffer svoNode, uint32_t leafLevel, uint3 cellDim, inout T hitInfo) {

    const float epsilon = exp2(-MAX_LEVEL);
    Stack stack = {};

    float3 p = ray.Origin;
    float3 d = ray.Direction;

    // get rid of small ray direction
    if(abs(d.x) < epsilon) d.x = copy_sign_32f(epsilon, d.x);
    if(abs(d.y) < epsilon) d.y = copy_sign_32f(epsilon, d.y);
    if(abs(d.z) < epsilon) d.z = copy_sign_32f(epsilon, d.z);

    d = normalize(d);

    // change range to [1,2] means we can easy to handle positive and negtive ray directions 
    // x = Px + t * dx ==> t = x/dx - Ox/dx 
    float3 t_coef = 1.0 / -abs(d);
    float3 t_bias = t_coef * p;

    // this means positive dir
    uint32_t octant_mask = 0;
    if (d.x > 0) octant_mask ^= 1, t_bias.x = 3.0 * t_coef.x - t_bias.x;
    if (d.y > 0) octant_mask ^= 2, t_bias.y = 3.0 * t_coef.y - t_bias.y;
    if (d.z > 0) octant_mask ^= 4, t_bias.z = 3.0 * t_coef.z - t_bias.z;

    float3 txyz = 2.0 * t_coef - t_bias;
    float t_min = max(max(txyz.x, txyz.y), txyz.z);

    txyz -= t_coef;
    float t_max = min(min(txyz.x, txyz.y), txyz.z);
    float h = t_max;

    // min should clamp to zeroï¼Œmax should not
    t_min = max(t_min, 0.0);

    uint32_t parentAddress = 0;
    uint32_t idx = 0;
    float3 pos = float3(1.0, 1.0, 1.0);
    int32_t scale = MAX_LEVEL - 1;
    float scale_exp2 = 0.5;

    // this meas the mid point's t > t_min
    // e.g is x direction is positive, and mid min gt t_min, next child should choose child which x axis is left
    if (1.5 * t_coef.x - t_bias.x > t_min) idx ^= 1, pos.x = 1.5;
    if (1.5 * t_coef.y - t_bias.y > t_min) idx ^= 2, pos.y = 1.5;
    if (1.5 * t_coef.z - t_bias.z > t_min) idx ^= 4, pos.z = 1.5;

    while (scale < MAX_LEVEL) {
        uint32_t child_shift = idx ^ octant_mask;
        uint32_t parentNode = svoNode.Load(parentAddress * 4);

        if (is_leaf_node(parentNode, scale, leafLevel)) {
            bool hitted = hitInfo.deal_if_hitted(parentNode, child_shift, scale, stack, scale_exp2, t_min);
            if(hitted) return;
        }

        // determind the max-t value of the cube
        // for the [1,2] range and the euqaltion: x = Px + t * dx ==> t = x/dx - Ox/dx 
        // we can caculate the right t time now despite of the positive/negtive direction
        // notice: pos may modified to 1.5
        // corner means the middle point of t
        float3 t_corner = pos * t_coef - t_bias;
        float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

        // check is child is a node
        if (is_valid_node(parentNode) && !is_leaf_node(parentNode, scale, leafLevel) && t_min <= t_max) {
            uint32_t childAddress = get_child_index(parentNode) * 8 + child_shift;
            float tv_max = min(t_max, tc_max);
            float half_scale = scale_exp2 * 0.5;
            // center means is the center of min * corner
            float3 t_center = half_scale * t_coef + t_corner;
            
            if (t_min <= tv_max) {
                // push
                stack.StackData[scale] = int4(parentAddress, asint(t_max), asint(scale_exp2), child_shift);
                h = tc_max;
                parentAddress = childAddress;

                idx = 0;
                --scale;
                scale_exp2 = half_scale;

                if (t_center.x > t_min) idx ^= 1, pos.x += scale_exp2;
                if (t_center.y > t_min) idx ^= 2, pos.y += scale_exp2;
                if (t_center.z > t_min) idx ^= 4, pos.z += scale_exp2;

                t_max = tv_max;
                continue;
            }
        }

        // advance
        int32_t step_mask = 0;
        // if t_corner is min than tc_max, we should choose the axis to next
        // notice: in our [1,2] algorithm pos sub means advance, add means backword 
        if (t_corner.x <= tc_max) step_mask ^= 1, pos.x -= scale_exp2;
        if (t_corner.y <= tc_max) step_mask ^= 2, pos.y -= scale_exp2;
        if (t_corner.z <= tc_max) step_mask ^= 4, pos.z -= scale_exp2;

        t_min = tc_max;
        idx ^= step_mask;

        // pop
        // index flip & direction is not same, need pop
        if ((idx & step_mask) != 0)
        {
            uint32_t differing_bits = 0;
            if ((step_mask & 1) != 0) differing_bits |= asint(pos.x) ^ asint(pos.x + scale_exp2);
            if ((step_mask & 2) != 0) differing_bits |= asint(pos.y) ^ asint(pos.y + scale_exp2);
            if ((step_mask & 4) != 0) differing_bits |= asint(pos.z) ^ asint(pos.z + scale_exp2);
            // for some number magic, we can decide parent scale
            // also can decide the exp2
            scale = (asint((float)differing_bits) >> 23) - 127;
            scale_exp2 = asfloat((scale - MAX_LEVEL + 127) << 23);

            int4 stackEntry = stack.StackData[scale];
            parentAddress = stackEntry.x;
            t_max = asfloat(stackEntry.y);
            
            int shx = asint(pos.x) >> scale;
            int shy = asint(pos.y) >> scale;
            int shz = asint(pos.z) >> scale;
            pos.x = asfloat(shx << scale);
            pos.y = asfloat(shy << scale);
            pos.z = asfloat(shz << scale);
            idx = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);
            h = 0.0;
        }
    }
}

inline uint32_t traverse_simple(uint3 cellIndex, uint3 curCellDim, uint32_t numLevels, RWByteAddressBuffer svNodeNext, out uint32_t foundOnLevel) {
    uint3 childRelative = uint3(0);
    uint3 childDim = curCellDim;

    uint32_t curID = 0;
    foundOnLevel = 0;
    uint3 curRelative = uint3(0);
  
    for (uint iLevel = 0; iLevel < numLevels; ++iLevel) {
        foundOnLevel = iLevel;
        uint32_t curNodeData = svNodeNext.Load(curID * 4);

        if(!is_valid_node(curNodeData)) {
            foundOnLevel = iLevel - 1;
            break;
        }

        curCellDim = childDim;
        curRelative = childRelative;

        childDim >>= 1;
        childRelative = step(childDim, cellIndex);
        cellIndex -= childDim * childRelative;

        if(get_child_index(curNodeData) == 0) {
            break;
        }

        curID = get_child_index(curNodeData) * 8 + (childRelative.x | childRelative.y << 1 | childRelative.z << 2);

    } // level-for
    return curID;
}

inline uint32_t traverse_return_child_relative(uint3 cellIndex, uint3 curCellDim, uint32_t numLevels, RWByteAddressBuffer svNodeNext, out uint32_t foundOnLevel, out uint3 childRelative) {
    childRelative = uint3(0);
    uint3 childDim = curCellDim;

    uint32_t curID = 0;
    foundOnLevel = 0;
    uint3 curRelative = uint3(0);
  
    for (uint iLevel = 0; iLevel < numLevels; ++iLevel) {
        foundOnLevel = iLevel;
        uint32_t curNodeData = svNodeNext.Load(curID * 4);

        if(!is_valid_node(curNodeData)) {
            foundOnLevel = iLevel - 1;
            break;
        }

        curCellDim = childDim;
        curRelative = childRelative;

        childDim >>= 1;
        childRelative = step(childDim, cellIndex);
        cellIndex -= childDim * childRelative;

        if(get_child_index(curNodeData) == 0) {
            break;
        }

        curID = get_child_index(curNodeData) * 8 + (childRelative.x | childRelative.y << 1 | childRelative.z << 2);

    } // level-for
    return curID;
}


inline uint32_t traverse_return_child_relative_dim(uint3 cellIndex, inout uint3 childDim, uint32_t numLevels, RWByteAddressBuffer svNodeNext, out uint32_t foundOnLevel, out uint3 childRelative) {
    childRelative = uint3(0);

    uint3 curCellDim = uint3(0);
    uint32_t curID = 0;
    foundOnLevel = 0;
    uint3 curRelative = uint3(0);
  
    for (uint iLevel = 0; iLevel < numLevels; ++iLevel) {
        foundOnLevel = iLevel;
        uint32_t curNodeData = svNodeNext.Load(curID * 4);

        if(!is_valid_node(curNodeData)) {
            foundOnLevel = iLevel - 1;
            break;
        }

        curCellDim = childDim;
        curRelative = childRelative;

        childDim >>= 1;
        childRelative = step(childDim, cellIndex);
        cellIndex -= childDim * childRelative;

        if(get_child_index(curNodeData) == 0) {
            break;
        }

        curID = get_child_index(curNodeData) * 8 + (childRelative.x | childRelative.y << 1 | childRelative.z << 2);

    } // level-for
    return curID;
}
