#pragma once
#include "Samples/SvoGi/Shaders/VoxelizationTracing.slangh"

int32_t get_lod_level(float t) {
    float d = max(g_NodeSizes[bufVoxelMeta.TotalLevel], t * CONE_COEffICIENT2);
    return max(bufVoxelMeta.TotalLevel - ceil(log2(d / g_NodeSizes[bufVoxelMeta.TotalLevel])), 0);
}

float4 cone_tracing(in RayDesc ray, in float3 aperture, in VoxelizationMeta bufVoxelMeta, in RWByteAddressBuffer svNodeNext, out float occlusion) {
    float4 finalColor = {};

    float tEnter = 0.0f;
    float tLeave = 0.0f;
    if (!intersect_ray_with_AABB(ray, float3(1.0), float3(2.0), tEnter, tLeave)) {
        return finalColor;
    }

    float tCur = max(tEnter, 0.0f);
    int32_t curLevel = get_lod_level(tCur);

    // first step
    tCur += g_NodeSizes[curLevel] * CONE_COEffICIENT1;

    while(tCur < tLeave && finalColor.a < 0.99f) {
        float3 posTex = ray.Origin + ray.Direction * tCur;
        curLevel = get_lod_level(tCur);
        tCur += g_NodeSizes[curLevel] * CONE_COEffICIENT1;

        uint3 posCell = (posTex - float3(1.0f)) * bufVoxelMeta.CellDim;

        uint32_t pNodeAddress = 0;
        float3 cMin = {};
        float3 cMax = {};
        float3 pMin = {};
        float3 pMax = {};

        uint32_t cNodeAddress = traverse_level(posCell, bufVoxelMeta.CellDim, curLevel, svNodeNext, pNodeAddress, pMin, pMax, cMin, cMax);

    }
    return finalColor;
}
