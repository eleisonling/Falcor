#pragma once
#include "Samples/SvoGi/Shaders/VoxelizationTracing.slangh"


float4 cone_tracing(in RayDesc ray, in float3 aperture, in VoxelizationMeta bufVoxelMeta, in RWByteAddressBuffer svoNodeNext, in RWByteAddressBuffer svoNodeColor,
    in Texture3D<float4> texBrickVal, in SamplerState spTexSampler,in float maxDistance) {

    float4 pColor = {};
    float4 cColor = {};
    float4 finalColor = {};

    float tEnter = 0.0f;
    float tLeave = 0.0f;

    float3 pMin = {};
    float3 pMax = {};
    float3 cMin = {};
    float3 cMax = {};

    float nodeSize = g_NodeSizes[bufVoxelMeta.TotalLevel - 1];
    const float voxelStep = 1.0f / float(bufVoxelMeta.BrickPoolResolution);

    if (!intersect_ray_with_AABB(ray, float3(0.0), float3(1.0), tEnter, tLeave)) {
        return finalColor;
    }

    for(float d = tEnter + nodeSize; d < tLeave; d += nodeSize) {
        const float3 posTex = ray.Origin + ray.Direction * d;
        nodeSize = clamp(CONE_COEffICIENT2 * d, g_NodeSizes[bufVoxelMeta.TotalLevel - 1], 1.0f);
        const float sampleLOD = clamp(log2(1.0f / nodeSize), 0.0f, float(bufVoxelMeta.TotalLevel) - 1.00001);
        const uint32_t cLevel = uint32_t(ceil(sampleLOD));
        nodeSize = g_NodeSizes[cLevel];

        uint3 posCell = uint3(floor(posTex * (bufVoxelMeta.CellDim - 1)));
        uint32_t pNodeAddress = 0;
        uint32_t onLevel = 0;
        uint3 childRelative = {};
        float cScale = 1.0f;

        uint32_t cNodeAddress = traverse_level(posCell, bufVoxelMeta.CellDim, cLevel, svoNodeNext, onLevel, childRelative, pNodeAddress, pMin, pMax, cMin, cMax, cScale);
        if(onLevel != cLevel - 1) continue;

        float alphaCorrection = g_NodeSizes[bufVoxelMeta.TotalLevel] / g_NodeSizes[cLevel + 1];

        uint32_t pNodeData = svoNodeNext.Load(pNodeAddress * 4);
        uint32_t cNodeData = svoNodeNext.Load(cNodeAddress * 4);

        uint32_t leafPointer = bufSvoNodeColor.Load(get_child_index(pNodeData) * 8 * 4);
        uint3 pBrickCoords = uint_XYZ10_to_uint3(leafPointer);
        float3 pBrickUVW = (float3(pBrickCoords) + 0.5) / bufVoxelMeta.BrickPoolResolution;
        float3 pEnter = (posTex - pMin) / (2 * cScale);
        float3 pEnterUVW = pBrickUVW + pEnter * (2 * voxelStep);
        pColor = texBrickVal.SampleLevel(spTexSampler, pEnterUVW, 0);
        correct_alpha(pColor, alphaCorrection * 2);


        leafPointer = bufSvoNodeColor.Load(get_child_index(cNodeData) * 8 * 4);
        uint3 cBrickCoords = uint_XYZ10_to_uint3(leafPointer);
        float3 cBrickUVW = (float3(cBrickCoords) + 0.5) / bufVoxelMeta.BrickPoolResolution;
        float3 cEnter = (posTex - cMin) / cScale;
        float3 cEnterUVW = cBrickUVW + cEnter * (2 * voxelStep);
        cColor = texBrickVal.SampleLevel(spTexSampler, cEnterUVW, 0);
        correct_alpha(cColor, alphaCorrection);

        float4 composedColor = lerp(pColor, cColor, frac(sampleLOD));
        finalColor += (1 - finalColor.a) * composedColor;

        if (finalColor.a > 0.99 || (maxDistance > 0.000001 && d >= maxDistance)) {
            break;
        }

    }
    return finalColor;
}
