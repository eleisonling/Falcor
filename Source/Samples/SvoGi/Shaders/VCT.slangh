#pragma once
#include "Samples/SvoGi/Shaders/VoxelizationTracing.slangh"

int32_t get_lod_level(in VoxelizationMeta bufVoxelMeta, float t, out float cScale) {
    float d = max(g_NodeSizes[bufVoxelMeta.TotalLevel], t * CONE_COEffICIENT2);
    float fLod = log2(d / g_NodeSizes[bufVoxelMeta.TotalLevel]);
    cScale = frac(fLod);
    return max(bufVoxelMeta.TotalLevel - floor(fLod), 1);
}

float4 cone_tracing(in RayDesc ray, in float3 aperture, in VoxelizationMeta bufVoxelMeta, in RWByteAddressBuffer svoNodeNext,
    in RWByteAddressBuffer svoNodeColor, in Texture3D<float4> texBrickVal, in SamplerState spTexSampler,float fOcclusionDecay, out float occlusion) {

    float4 curColor = {};
    float4 childColor = {};
    float4 finalColor = {};
    occlusion = 0.0f;

    float tEnter = 0.0f;
    float tLeave = 0.0f;
    if (!intersect_ray_with_AABB(ray, float3(1.0), float3(2.0), tEnter, tLeave)) {
        return finalColor;
    }

    float tLast = 0.0f;
    float tCur = max(tEnter, 0.0f);
    float cScale = 1.0f;
    int32_t curLevel = get_lod_level(bufVoxelMeta, tCur, cScale);

    // first step
    tCur += g_NodeSizes[curLevel] * CONE_COEffICIENT1;

    while(tCur < tLeave && finalColor.a <= 0.99f) {

        tCur += g_NodeSizes[curLevel] * CONE_COEffICIENT1;
        float3 posTex = ray.Origin + ray.Direction * tCur;
        curLevel = get_lod_level(bufVoxelMeta, tCur, cScale);
        uint3 posCell = (posTex - float3(1.0f)) * bufVoxelMeta.CellDim;

        uint32_t pNodeAddress = 0;
        float3 curMin = {};
        float3 curMax = {};
        float3 childMin = {};
        float3 childMax = {};
        uint32_t onLevel = 0;
        uint3 childRelative = {};
        float childScale = 1.0f;
        float curOpacity = 0.0f;
        float childOpacity = 0.0f;


        uint32_t cNodeAddress = traverse_level(posCell, bufVoxelMeta.CellDim, curLevel, svoNodeNext, onLevel, childRelative, pNodeAddress, curMin, curMax, childMin, childMax, childScale);
        uint32_t pNodeData = svoNodeNext.Load(pNodeAddress * 4);
        uint32_t cNodeData = svoNodeNext.Load(cNodeAddress * 4);

        if(onLevel != curLevel - 1) continue;

        float curScale = childScale * 2.0f;
        float segmentLength = tCur - tLast;
        tLast = tCur;

        float tCurEnter = 0.f;
        float tCurLeave = 0.f;
        if(is_valid_node(pNodeData) && intersect_ray_with_AABB(ray, curMin, curMax, tCurEnter, tCurLeave)) {
            uint32_t leafPointer = bufSvoNodeColor.Load(get_child_index(pNodeData) * 8 * 4);
            uint3 curBrickCoords = uint_XYZ10_to_uint3(leafPointer);
            float3 curEnter = (posTex - curMin) / curScale;
            float3 curLeave = ((posTex + ray.Direction * (tCurLeave - tCurEnter)) - curMin) / curScale;
            curColor = ray_cast(finalColor, curBrickCoords, curEnter, curLeave, ray.Direction, curLevel - 1, bufVoxelMeta, texBrickValue, spTexSampler, segmentLength, curOpacity);
        }

        float tChildEnter = 0.f;
        float tChildLeave = 0.f;
        if(is_valid_node(cNodeData) && intersect_ray_with_AABB(ray, childMin, childMax, tChildEnter, tChildLeave)) {
            uint32_t leafPointer = bufSvoNodeColor.Load(get_child_index(cNodeData) * 8 * 4);
            uint3 childBrickCoords = uint_XYZ10_to_uint3(leafPointer);
            float3 childEnter = (posTex - childMin) / childScale;
            float3 childLeave = ((posTex + ray.Direction * (tChildLeave - tChildEnter)) - childMin) / childScale;
            childColor = ray_cast(finalColor, childBrickCoords, childEnter, childLeave, ray.Direction, curLevel, bufVoxelMeta, texBrickValue, spTexSampler, segmentLength, childOpacity);
        }

        finalColor = lerp(childColor, curColor, cScale);
        float composOpacity = lerp(childOpacity, curOpacity, cScale);
        occlusion += (1.0f - occlusion) * composOpacity / (1.0f + (tCur + g_NodeSizes[curLevel]) * fOcclusionDecay);
    }
    return finalColor;
}
